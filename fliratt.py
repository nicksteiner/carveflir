__author__ = 'nsteiner'
from collections import OrderedDict
import numpy as np

geolocation_variables = OrderedDict(**{
     'center_lat':                  {'data_type': 'float',  'dimension': 'time'},
     'center_lat_standard_error':   {'data_type': 'float',  'dimension': 'time'},
     'center_lon':                  {'data_type': 'float',  'dimension': 'time'},
     'center_lon_standard_error':   {'data_type': 'float',  'dimension': 'time'},
     'geolocation_qc':              {'data_type': 'uint8',  'dimension': 'time'},
     'heading':                     {'data_type': 'float',  'dimension': 'time'},
     'heading_qc':                  {'data_type': 'uint8',  'dimension': 'time'},
     'height':                      {'data_type': 'float',  'dimension': 'time'},
     'height_standard_error':       {'data_type': 'float',  'dimension': 'time'},
     'pitch':                       {'data_type': 'float',  'dimension': 'time'},
     'pitch_qc':                    {'data_type': 'uint8',  'dimension': 'time'},
     'roll':                        {'data_type': 'float',  'dimension': 'time'},
     'roll_qc':                     {'data_type': 'uint8',  'dimension': 'time'},
     'time':                        {'data_type': 'int64',  'dimension': 'time'},
     'time_stamp':                  {'data_type': 'string', 'dimension': 'time'}})

geolocation_attributes = OrderedDict(**{
    'center_lat': {                'long_name': u'latitude_of_footprint_center',
                                    'standard_name': u'latitude',
                                    'units': u'degrees_north',
                                    'valid_max': 90,
                                    'valid_min': -90},
    'center_lat_standard_error': {  'long_name': u'uncertainly_of_center_latitude',
                                    'standard_name': u'latitude standard_error',
                                    'units': u'degrees_north',
                                    'valid_max': 90,
                                    'valid_min': 0},
    'center_lon': {                 'long_name': u'longitude_of_footprint_center',
                                    'standard_name': u'longitude',
                                    'units': u'degrees_east',
                                    'valid_max': 180,
                                    'valid_min': -180},
    'center_lon_standard_error': {  'long_name': u'uncertainly_of_center_longitude',
                                    'standard_name': u'longitude standard_error',
                                    'units': u'degrees_east',
                                    'valid_max': 90,
                                    'valid_min': 0},
    'geolocation_qc': {             'flag_masks': u'255b, 255b',
                                    'flag_meanings': u'Success Error',
                                    'flag_values': np.array([0, 1], dtype='uint8'),
                                    'long_name': u'geolocation status'},
    'height': {                     'long_name': u'height',
                                    'positive': u'up',
                                    'standard_name': u'height',
                                    'units': u'meters',
                                    'valid_max': 10000,
                                    'valid_min': 0},
    'height_standard_error': {      'long_name': u'uncertainty_of_height',
                                    'standard_name': u'height standard_error',
                                    'units': u'meters',
                                    'valid_max': 20,
                                    'valid_min': 0},
    'time': {                       'long_name': u'time',
                                    'standard_name': u'time',
                                    'units': u'seconds since 1980-1-6 0:0:0'},

    'time_stamp': {                 'long_name': u'ISO_8601_UTC_time_string'},

    'heading': {                    'long_name': u'aircraft_heading',
                                    'standard_name': u'platform_course',
                                    'units': u'degree',
                                    'valid_max': 90,
                                    'valid_min': -90},
    'heading_qc': {                 'flag_masks': u'255b, 255b, 255b',
                                    'flag_meanings': u'Valid OutOfRange Error',
                                    'flag_values': np.array([0, 1, 2], dtype='uint8'),
                                    'long_name': u'aircraft_heading status',
                                    'standard_name': u'platform_course status_flag'},
    'pitch': {                      'long_name': u'aircraft_pitch',
                                    'standard_name': u'platform_pitch_angle',
                                    'units': u'degree',
                                    'valid_max': 90,
                                    'valid_min': -90},
    'pitch_qc': {                   'flag_masks': u'255b, 255b, 255b',
                                    'flag_meanings': u'Valid OutOfRange Error',
                                    'flag_values': np.array([0, 1, 2], dtype='uint8'),
                                    'long_name': u'aircraft_pitch status',
                                    'standard_name': u'platform_pitch_angle status_flag'},
    'roll': {                       'long_name': u'aircraft_roll',
                                    'standard_name': u'platform_roll_angle',
                                    'units': u'degree',
                                    'valid_max': 180,
                                    'valid_min': -180},
    'roll_qc': {                    'flag_masks': u'255b, 255b, 255b',
                                    'flag_meanings': u'Valid OutOfRange Error',
                                    'flag_values': np.array([0, 1, 2], dtype='uint8'),
                                    'long_name': u'aircraft_roll status',
                                    'standard_name': u'platform_roll_angle status_flag'}})

flir01a_sm_variables = OrderedDict(**{
    'radiance':   {'data_type': 'uint16',  'dimension': ('time', 'scan', 'raster')}
        })

flir01a_sm_include = OrderedDict(**{
    'radiance': {'AtmA1': 'nfcAtmA1_0',
                 'AtmA2': 'nfcAtmA2_0',
                 'AtmB1': 'nfcAtmB1_0',
                 'AtmX': 'nfcAtmX_0',
                 'B': 'nfcB_0',
                 'BGValue': 'nfcBGValue_0',
                 'BandpassHigh': 'nfcBandpassHigh_0',
                 'BandpassLow': 'nfcBandpassLow_0',
                 'C0': 'nfcC0_0',
                 'C1': 'nfcC1_0',
                 'C2': 'nfcC2_0',
                 'C3': 'nfcC3_0',
                 'C4': 'nfcC4_0',
                 'C5': 'nfcC5_0',
                 'C6': 'nfcC6_0',
                 'F': 'nfcF_0',
                 'FrameRate': 'FRate_0',
                 'IntegrationTime': 'ITime_0',
                 'MaxCounts': 'nfcMaxCounts_0',
                 'MaxRadiance': 'nfcMaxRad_0',
                 'MaxTemperature': 'nfcMaxTemp_0',
                 'MinCounts': 'nfcMinCounts_0',
                 'MinRadiance': 'nfcMinRad_0',
                 'MinTemperature': 'nfcMinTemp_0',
                 'PolynomialOrder': 'nfcPolyOrder_0',
                 'R': 'nfcR_0',
                 'TempC0': 'nfcTempC0_0',
                 'TempC1': 'nfcTempC1_0',
                 'TempC2': 'nfcTempC2_0'}})

flir01a_sm_include_attributes = ('R', 'FrameRate', 'MaxRadiance', 'MinRadiance', 'MinTemperature', 'B', 'TempC0',
                         'PolynomialOrder', 'BandpassHigh', 'C4', 'TempC1', 'F', 'AtmB1', 'MaxTemperature',
                         'C3', 'TempC2', 'C5', 'C2', 'AtmA2', 'AtmA1', 'BGValue', 'C1', 'MinCounts', 'AtmX',
                         'BandpassLow', 'C0', 'IntegrationTime', 'C6', 'MaxCounts', 'AtmA2')

def get_flir01a_attr(record):
    sm_attributes_base = OrderedDict(**{
        'radiance': {   'long_name': 'flir_radiance_counts_at_sensor',
                        'standard_name': 'radiance',
                        'units': 'counts [n]',
                        'valid_max': record.MaxCounts,
                        'valid_min': record.MinCounts,
                        'radiance_coefficients': record.rad_coefficients}})
    include_record = dict([(key, getattr(record, key)) for key in flir01a_sm_include_attributes])
    sm_attributes_base['radiance'].update(include_record)
    return sm_attributes_base
